(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const l of e)if(l.type==="childList")for(const o of l.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function s(e){const l={};return e.integrity&&(l.integrity=e.integrity),e.referrerPolicy&&(l.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?l.credentials="include":e.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(e){if(e.ep)return;e.ep=!0;const l=s(e);fetch(e.href,l)}})();const $={II:{id:"II",nameZh:"相同球 相同盒",nameEn:"Identical Balls, Identical Boxes",calculate:(t,n,s=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let e=0;e<=n;e++)r[0][e]=1;for(let e=1;e<=t;e++)for(let l=1;l<=n;l++)r[e][l]=r[e][l-1],e>=l&&(r[e][l]+=r[e-l][l]);return r},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-m, m)
递推 2：f(n, m) = Σ_{k=1}^m f(n-k, k)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-m, m)
Recurrence 2: f(n, m) = Σ_{k=1}^m f(n-k, k)`,closedZh:"组合意义：整数分拆 (Partitions of n into ≤ m parts)",closedEn:"Note: Integer partitions of n into at most m parts",explainZh:`相同球相同盒 (整数分拆)。总数 f(n, m) 表示将 n 拆分为不超过 m 个正整数之和。
【视角 1】：讨论是否有空盒。f(n, m-1) 表示至少一个空盒；f(n-m, m) 表示全部装满（先各发一个球）。
【视角 2】：按非空盒子数 k 累加。由组合恒等式可知，分拆为“恰好 k 组”的方法数等于 f(n-k, k)。将 k 从 1 到 m 累加即得总数，在矩阵中形成斜线。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种分拆方式。`,explainEn:`Identical Balls, Identical Boxes (Integer Partitions).
[View 1]: Empty boxes f(n, m-1) vs No empty boxes f(n-m, m).
[View 2]: Summing over non-empty box count k. The number of partitions into "exactly k" parts equals f(n-k, k). Summing k from 1 to m forms a diagonal.
[Result]: When n={n}, m={m}, there are {res} ways.`,modeLabels:["视角 1 (空盒递归)","视角 2 (斜线累加)"],getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=1;e<=n;e++)t-e>=0&&r.push({r:t-e,c:e,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"空盒"},{r:t-n,c:n,cls:"cell-source-2",label:"全满"}]}},DI:{id:"DI",nameZh:"不同球 相同盒",nameEn:"Distinct Balls, Identical Boxes",calculate:(t,n,s=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));r[0][0]=1;for(let l=1;l<=t;l++)for(let o=1;o<=n;o++)r[l][o]=o*r[l-1][o]+r[l-1][o-1];if(!s)return{matrix:r,isStirling:!0};const e=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let l=0;l<=t;l++)for(let o=1;o<=n;o++){let a=0;for(let u=1;u<=o;u++)a+=r[l][u];e[l][o]=l===0?1:a}return{matrix:e,componentMatrix:r}},formulaZh:`递推 1 (恰好 m 盒)：S(n, m) = m·S(n-1, m) + S(n-1, m-1)
公式 2 (至多 m 盒)：f(n, m) = Σ_{k=1}^m S(n, k)`,formulaEn:`Recurrence 1 (Exactly m): S(n, m) = m·S(n-1, m) + S(n-1, m-1)
Formula 2 (At most m): f(n, m) = Σ_{k=1}^m S(n, k)`,closedZh:"组合意义：不同球放入相同盒子 (盒子间无区别，像完全一样的袋子)",closedEn:"Note: Distinct balls into identical boxes (Individual items in generic bags)",explainZh:`不同球相同盒 (斯特林数)。由于盒子不可辨，第 n 个球放在哪个空盒里都没有区别。
【深度推导】：考虑第 n 个球的去向：
1. 它单独占领一个新盒子：剩下 n-1 个球放在 m-1 个盒子里，即 S(n-1, m-1)。
2. 它不单独占盒子：而是挤进已有的 m 个盒子之一。因为它有 m 种选择，所以是 m * S(n-1, m)。
【总数逻辑】：如果要计算“至多 m 盒”，则需将放入 1 到 m 个盒子的方案数全部相加：f(n, m) = Σ S(n, k)。
【当前结果】：当 n={n}, m={m} 时，总方案数为 {res}。`,explainEn:`Distinct Balls, Identical Boxes (Stirling Numbers).
[Deep Reasoning]: Since boxes are indistinguishable, it doesn't matter which empty box the n-th ball enters.
1. n-th ball forms its own box: Put the other n-1 balls into m-1 boxes → S(n-1, m-1).
2. n-th ball joins an existing box: There are m occupied boxes to choose from → m * S(n-1, m).
[Total Logic]: For "At most m boxes", we sum options from 1 to m: f(n, m) = Σ S(n, k).
[Result]: When n={n}, m={m}, there are {res} ways in total.`,modeLabels:["恰好 m 盒 (Exactly m)","至多 m 盒 (At most m)"],getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=1;e<=n;e++)r.push({r:t,c:e,cls:"cell-source-group",label:`k=${e}`,useStirling:!0});return r}else return[{r:t-1,c:n,cls:"cell-source-1",label:"m×"},{r:t-1,c:n-1,cls:"cell-source-2"}]}},ID:{id:"ID",nameZh:"相同球 不同盒",nameEn:"Identical Balls, Distinct Boxes",calculate:(t,n,s=!1)=>{const e=Array.from({length:31},()=>Array(31).fill(0));for(let o=0;o<=30;o++){e[o][0]=1;for(let a=1;a<=o;a++)e[o][a]=e[o-1][a-1]+e[o-1][a]}const l=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let o=0;o<=t;o++)for(let a=1;a<=n;a++)l[o][a]=e[o+a-1][a-1];return l},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-1, m)
递推 2：f(n, m) = Σ_{k=0}^n f(k, m-1)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-1, m)
Recurrence 2: f(n, m) = Σ_{k=0}^n f(k, m-1)`,closedZh:"组合意义：隔板法 (C(n+m-1, m-1))",closedEn:"Note: Identical balls into distinct boxes (Stars and Bars)",modeLabels:["递推 1 (增量递归)","递推 2 (逐项累加)"],explainZh:`相同球不同盒 (隔板法)。
【书本做法】：使用隔板法，通解为 C(n+m-1, m-1)。
【递推推导】：如果你已经知道部分结果，可以通过最后一个盒子来推导：
最后一个盒子可以放 0 个，1 个... 一直到 n 个球。如果最后一个盒子放了 k 个，那么剩下的球就放进前 m-1 个盒子，方案数为 f(n-k, m-1)。
【更简递推】：f(n, m) = f(n, m-1) [第一个盒子为空] + f(n-1, m) [第一个盒子至少有1个球]。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种放法。`,explainEn:`Identical Balls, Distinct Boxes (Stars and Bars).
[Standard View]: General solution is C(n+m-1, m-1).
[Recursive Reasoning]: You can derive more results from known ones using the "last box" logic:
The last box can contain k balls (where 0 ≤ k ≤ n). For each choice of k, the remaining balls are distributed in m-1 boxes, giving Σ f(n-k, m-1).
[Simplified]: f(n, m) = f(n, m-1) [1st box empty] + f(n-1, m) [1st box ≥ 1 ball].
[Result]: When n={n}, m={m}, there are {res} ways.`,getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=0;e<=t;e++)r.push({r:e,c:n-1,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"0球"},{r:t-1,c:n,cls:"cell-source-2",label:"≥1球"}]}},DD:{id:"DD",nameZh:"不同球 不同盒",nameEn:"Distinct Balls, Distinct Boxes",calculate:(t,n)=>{const s=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let r=0;r<=n;r++)s[0][r]=1;for(let r=1;r<=t;r++)for(let e=0;e<=n;e++)s[r][e]=Math.pow(e,r);return s},formulaZh:"递推式：f(n, m) = m · f(n-1, m)",formulaEn:"Recurrence: f(n, m) = m · f(n-1, m)",closedZh:"通项公式：m^n (每个球有 m 种选择)",closedEn:"General Form: m^n (Each ball has m choices)",explainZh:`不同球不同盒 (指数模型)。
【基本逻辑】：对于每个球来说都有 m 种选择（盒子是不同的），所以总共有 m^n 种方案。
【递归通式】：假设你已经放好了 n-1 个球，即 f(n-1, m)。现在要放第 n 个球，它有 m 种选盒子的方法。因此：f(n, m) = m * f(n-1, m)。
【边界条件】：f(0, m) = 1 (没有球也是 1 种状态)。
【当前结果】：当 n={n}, m={m} 时，共有 {m}^{n} = {res} 种放法。`,explainEn:`Distinct Balls, Distinct Boxes (Exponential Model).
[Basic Logic]: Each of the n distinct balls has m choices of distinct boxes, leading to m^n.
[Recursive Logic]: Suppose n-1 balls are already placed, f(n-1, m). For the n-th ball, there are m box options. Thus: f(n, m) = m * f(n-1, m).
[Boundary]: f(0, m) = 1.
[Result]: When n={n}, m={m}, there are {m}^{n} = {res} ways.`,getDependencies:(t,n)=>[{r:t-1,c:n,cls:"cell-source-1",label:"m×"}]}};let d="II",m=5,c=3,h=!1,g=[];const y=document.getElementById("n-input"),E=document.getElementById("m-input"),w=document.getElementById("n-val"),L=document.getElementById("m-val"),R=document.getElementById("matrix-container"),T=document.querySelectorAll(".mode-btn"),N=document.querySelector(".formula-card"),p=document.getElementById("canvas"),i=p.getContext("2d"),W=document.querySelector(".visual-card");let f=window.innerWidth<640?7:10;function j(){m=parseInt(y.value),c=parseInt(E.value),w.textContent=m,L.textContent=c,O(),D(),x(),setTimeout(()=>{Z(),x()},100)}function O(){y.addEventListener("input",t=>{m=parseInt(t.target.value),w.textContent=m,D(),x()}),E.addEventListener("input",t=>{c=parseInt(t.target.value),L.textContent=c,D(),x()}),T.forEach(t=>{t.addEventListener("click",()=>{T.forEach(n=>n.classList.remove("active")),t.classList.add("active"),d=t.dataset.mode,h=!1,x()})}),N.addEventListener("click",t=>{$[d].formulaZh.includes(`
`)&&(h=!h,x())}),W.addEventListener("click",()=>{D(),C()}),window.addEventListener("resize",()=>{const t=window.innerWidth<640?7:10;t!==f&&(f=t,y.max=f,E.max=f,m>f&&(m=f,y.value=m,w.textContent=m),c>f&&(c=f,E.value=c,L.textContent=c),x()),Z()}),y.max=f,E.max=f,Z()}function Z(){const t=p.parentElement;p.width=t.clientWidth,p.height=t.clientHeight,C()}function x(){const t=$[d],n=t.calculate(f,f,h),r=(n.matrix||n)[m][c],e=o=>o.replace(/{n}/g,m).replace(/{m}/g,c).replace(/{res}/g,r);document.getElementById("explanation-zh").innerText=e(t.explainZh),document.getElementById("explanation-en").innerText=e(t.explainEn);const l=document.getElementById("recurrence-formula");if(l.innerHTML=t.formulaZh.replace(`
`,"<br>"),t.formulaZh.includes(`
`)){l.style.cursor="pointer",l.title="点击切换递推演示 / Click to toggle recurrence demo";const o=t.formulaZh.split(`
`),a=t.modeLabels||[];l.innerHTML=`<div class="${h?"":"active-formula"}">${a[0]?`<b>${a[0]}</b><br>`:""}${o[0]}</div>
                        <div class="${h?"active-formula":""}">${a[1]?`<b>${a[1]}</b><br>`:""}${o[1]}</div>`}else l.style.cursor="default",l.title="";document.getElementById("closed-formula").innerHTML=t.closedZh,P(),C()}function P(){const t=$[d],n=t.calculate(f,f,h),s=n.matrix||n;let r="<table><thead><tr><th>n\\m</th>";for(let e=0;e<=f;e++)r+=`<th>${e}</th>`;r+="</tr></thead><tbody>";for(let e=0;e<=f;e++){r+=`<tr><th>${e}</th>`;for(let l=0;l<=f;l++){let o=s[e][l];const a=e===m&&l===c;let u="";h&&(d==="DI"?u=n.componentMatrix[e][l]:d==="II"&&(e>=l?u=s[e-l][l]:u=0));let I=a?"cell-active":"",k="",A=u!==""?`<span class="cell-corner">${u}</span>`:"";d==="DI"&&h&&n.componentMatrix;const b=t.getDependencies(m,c,h).find(v=>v.r===e&&v.c===l);b&&(d==="DI"&&h&&!a&&(o=n.componentMatrix[e][l]),a?I+=" cell-source-overlap":I=b.cls,b.label&&(k=`<span class="cell-label">${b.label}</span>`)),r+=`<td class="${I}" data-r="${e}" data-c="${l}">${k}${A}${o}</td>`}r+="</tr>"}r+="</tbody></table>",R.innerHTML=r,R.querySelectorAll("td").forEach(e=>{e.addEventListener("click",()=>{m=parseInt(e.dataset.r),c=parseInt(e.dataset.c),y.value=m,E.value=c,w.textContent=m,L.textContent=c,x()})})}function D(){if(g=Array.from({length:c},()=>[]),d.startsWith("D"))for(let t=0;t<m;t++){const n=Math.floor(Math.random()*c);g[n].push(t)}else{let t=m;for(let n=0;n<c-1;n++){const s=Math.floor(Math.random()*(t+1));for(let r=0;r<s;r++)g[n].push("ball");t-=s}for(let n=0;n<t;n++)g[c-1].push("ball")}d.endsWith("I")&&g.sort((t,n)=>n.length-t.length)}function C(){i.clearRect(0,0,p.width,p.height);const t=50,n=80,s=60,r=(p.width-2*t-c*n)/(c-1||1);i.fillStyle="#fff",i.font="bold 16px Outfit",i.textAlign="center";const e=$[d].calculate(10,10),l=e.matrix||e;i.fillText(`${m} Balls → ${c} Boxes: ${l[m][c]} ways`,p.width/2,30),i.font="12px Outfit",i.fillStyle=B("--text-secondary"),i.fillText("(点击卡片切换示例 / Click card to cycle examples)",p.width/2,50);for(let o=0;o<c;o++){const a=t+o*(n+r),u=p.height-120;i.strokeStyle=B("--accent-color"),i.lineWidth=2,i.strokeRect(a,u,n,s),i.fillStyle=B("--text-secondary"),i.font="12px Outfit",i.textAlign="center";const I=d.endsWith("D")?`Box ${o+1}`:`Part ${o+1}`;i.fillText(I,a+n/2,u+s+20);const k=g[o],A=6;k.forEach((S,b)=>{const v=a+15+b%4*15,M=u+15+Math.floor(b/4)*15;i.beginPath(),i.arc(v,M,A,0,Math.PI*2),typeof S=="number"?(i.fillStyle=`hsl(${S*360/m}, 70%, 60%)`,i.fill(),i.fillStyle="#fff",i.font="8px Outfit",i.fillText(S+1,v,M+3)):(i.fillStyle=B("--text-secondary"),i.fill())})}}function B(t){return getComputedStyle(document.documentElement).getPropertyValue(t).trim()}window.addEventListener("load",j);
