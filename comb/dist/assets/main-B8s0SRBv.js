/* empty css              */(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const l of e)if(l.type==="childList")for(const o of l.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function s(e){const l={};return e.integrity&&(l.integrity=e.integrity),e.referrerPolicy&&(l.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?l.credentials="include":e.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(e){if(e.ep)return;e.ep=!0;const l=s(e);fetch(e.href,l)}})();const w={II:{id:"II",nameZh:"相同球 相同盒",nameEn:"Identical Balls, Identical Boxes",calculate:(t,n,s=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let e=0;e<=n;e++)r[0][e]=1;for(let e=1;e<=t;e++)for(let l=1;l<=n;l++)r[e][l]=r[e][l-1],e>=l&&(r[e][l]+=r[e-l][l]);return r},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-m, m)
递推 2：f(n, m) = Σ_{k=1}^m f(n-k, k)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-m, m)
Recurrence 2: f(n, m) = Σ_{k=1}^m f(n-k, k)`,closedZh:"组合意义：整数分拆 (Partitions of n into ≤ m parts)",closedEn:"Note: Integer partitions of n into at most m parts",explainZh:`相同球相同盒 (整数分拆)。总数 f(n, m) 表示将 n 拆分为不超过 m 个正整数之和。
【视角 1】：讨论是否有空盒。f(n, m-1) 表示至少一个空盒；f(n-m, m) 表示全部装满（先各发一个球）。
【视角 2】：按非空盒子数 k 累加。由组合恒等式可知，分拆为“恰好 k 组”的方法数等于 f(n-k, k)。将 k 从 1 到 m 累加即得总数，在矩阵中形成斜线。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种分拆方式。`,explainEn:`Identical Balls, Identical Boxes (Integer Partitions).
[View 1]: Empty boxes f(n, m-1) vs No empty boxes f(n-m, m).
[View 2]: Summing over non-empty box count k. The number of partitions into "exactly k" parts equals f(n-k, k). Summing k from 1 to m forms a diagonal.
[Result]: When n={n}, m={m}, there are {res} ways.`,modeLabels:["视角 1 (空盒递归)","视角 2 (斜线累加)"],getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=1;e<=n;e++)t-e>=0&&r.push({r:t-e,c:e,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"空盒"},{r:t-n,c:n,cls:"cell-source-2",label:"全满"}]}},DI:{id:"DI",nameZh:"不同球 相同盒",nameEn:"Distinct Balls, Identical Boxes",calculate:(t,n,s=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));r[0][0]=1;for(let l=1;l<=t;l++)for(let o=1;o<=n;o++)r[l][o]=o*r[l-1][o]+r[l-1][o-1];if(!s)return{matrix:r,isStirling:!0};const e=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let l=0;l<=t;l++)for(let o=1;o<=n;o++){let a=0;for(let u=1;u<=o;u++)a+=r[l][u];e[l][o]=l===0?1:a}return{matrix:e,componentMatrix:r}},formulaZh:`递推 1 (恰好 m 盒)：S(n, m) = m·S(n-1, m) + S(n-1, m-1)
公式 2 (至多 m 盒)：f(n, m) = Σ_{k=1}^m S(n, k)`,formulaEn:`Recurrence 1 (Exactly m): S(n, m) = m·S(n-1, m) + S(n-1, m-1)
Formula 2 (At most m): f(n, m) = Σ_{k=1}^m S(n, k)`,closedZh:"组合意义：不同球放入相同盒子 (盒子间无区别，像完全一样的袋子)",closedEn:"Note: Distinct balls into identical boxes (Individual items in generic bags)",explainZh:`不同球相同盒 (斯特林数)。由于盒子不可辨，第 n 个球放在哪个空盒里都没有区别。
【深度推导】：考虑第 n 个球的去向：
1. 它单独占领一个新盒子：剩下 n-1 个球放在 m-1 个盒子里，即 S(n-1, m-1)。
2. 它不单独占盒子：而是挤进已有的 m 个盒子之一。因为它有 m 种选择，所以是 m * S(n-1, m)。
【总数逻辑】：如果要计算“至多 m 盒”，则需将放入 1 到 m 个盒子的方案数全部相加：f(n, m) = Σ S(n, k)。
【当前结果】：当 n={n}, m={m} 时，总方案数为 {res}。`,explainEn:`Distinct Balls, Identical Boxes (Stirling Numbers).
[Deep Reasoning]: Since boxes are indistinguishable, it doesn't matter which empty box the n-th ball enters.
1. n-th ball forms its own box: Put the other n-1 balls into m-1 boxes → S(n-1, m-1).
2. n-th ball joins an existing box: There are m occupied boxes to choose from → m * S(n-1, m).
[Total Logic]: For "At most m boxes", we sum options from 1 to m: f(n, m) = Σ S(n, k).
[Result]: When n={n}, m={m}, there are {res} ways in total.`,modeLabels:["恰好 m 盒 (Exactly m)","至多 m 盒 (At most m)"],getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=1;e<=n;e++)r.push({r:t,c:e,cls:"cell-source-group",label:`k=${e}`,useStirling:!0});return r}else return[{r:t-1,c:n,cls:"cell-source-1",label:"m×"},{r:t-1,c:n-1,cls:"cell-source-2"}]}},ID:{id:"ID",nameZh:"相同球 不同盒",nameEn:"Identical Balls, Distinct Boxes",calculate:(t,n,s=!1)=>{const e=Array.from({length:31},()=>Array(31).fill(0));for(let o=0;o<=30;o++){e[o][0]=1;for(let a=1;a<=o;a++)e[o][a]=e[o-1][a-1]+e[o-1][a]}const l=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let o=0;o<=t;o++)for(let a=1;a<=n;a++)l[o][a]=e[o+a-1][a-1];return l},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-1, m)
递推 2：f(n, m) = Σ_{k=0}^n f(k, m-1)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-1, m)
Recurrence 2: f(n, m) = Σ_{k=0}^n f(k, m-1)`,closedZh:"组合意义：隔板法 (C(n+m-1, m-1))",closedEn:"Note: Identical balls into distinct boxes (Stars and Bars)",modeLabels:["递推 1 (增量递归)","递推 2 (逐项累加)"],explainZh:`相同球不同盒 (隔板法)。
【书本做法】：使用隔板法，通解为 C(n+m-1, m-1)。
【逐项累加推导】：想象有 n 个球分给 m 个小朋友。我们按【最后一个小朋友拿到了几个球】来分类：
- 他拿 0 个：剩下的球分给前 m-1 人，即 f(n, m-1)；
- 他拿 1 个：剩下的球分给前 m-1 人，即 f(n-1, m-1)；
- ...直到他拿走所有球。
把这些所有互斥的情况加起来，就是总数。因此 f(n, m) = Σ f(k, m-1)。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种放法。`,explainEn:`Identical Balls, Distinct Boxes (Stars and Bars).
[Standard View]: General solution is C(n+m-1, m-1).
[Recursive Reasoning]: You can derive more results from known ones using the "last box" logic:
The last box can contain k balls (where 0 ≤ k ≤ n). For each choice of k, the remaining balls are distributed in m-1 boxes, giving Σ f(n-k, m-1).
[Simplified]: f(n, m) = f(n, m-1) [1st box empty] + f(n-1, m) [1st box ≥ 1 ball].
[Result]: When n={n}, m={m}, there are {res} ways.`,getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=0;e<=t;e++)r.push({r:e,c:n-1,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"0球"},{r:t-1,c:n,cls:"cell-source-2",label:"≥1球"}]}},DD:{id:"DD",nameZh:"不同球 不同盒",nameEn:"Distinct Balls, Distinct Boxes",calculate:(t,n)=>{const s=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let r=0;r<=n;r++)s[0][r]=1;for(let r=1;r<=t;r++)for(let e=0;e<=n;e++)s[r][e]=Math.pow(e,r);return s},formulaZh:"递推式：f(n, m) = m · f(n-1, m)",formulaEn:"Recurrence: f(n, m) = m · f(n-1, m)",closedZh:"通项公式：m^n (每个球有 m 种选择)",closedEn:"General Form: m^n (Each ball has m choices)",explainZh:`不同球不同盒 (指数模型)。
【基本逻辑】：对于每个球来说都有 m 种选择（盒子是不同的），所以总共有 m^n 种方案。
【递归通式】：假设你已经放好了 n-1 个球，即 f(n-1, m)。现在要放第 n 个球，它有 m 种选盒子的方法。因此：f(n, m) = m * f(n-1, m)。
【边界条件】：f(0, m) = 1 (没有球也是 1 种状态)。
【当前结果】：当 n={n}, m={m} 时，共有 {m}^{n} = {res} 种放法。`,explainEn:`Distinct Balls, Distinct Boxes (Exponential Model).
[Basic Logic]: Each of the n distinct balls has m choices of distinct boxes, leading to m^n.
[Recursive Logic]: Suppose n-1 balls are already placed, f(n-1, m). For the n-th ball, there are m box options. Thus: f(n, m) = m * f(n-1, m).
[Boundary]: f(0, m) = 1.
[Result]: When n={n}, m={m}, there are {m}^{n} = {res} ways.`,getDependencies:(t,n)=>[{r:t-1,c:n,cls:"cell-source-1",label:"m×"}]}};let d="II",m=5,c=3,p=!1,S=[],v,E,I,D,R,Z,j,h,i,P;const b=t=>document.getElementById(t),V=t=>document.querySelectorAll(t),O=t=>document.querySelector(t);let f=window.innerWidth<640?7:10;function W(){v=b("n-input"),E=b("m-input"),I=b("n-val"),D=b("m-val"),R=b("matrix-container"),Z=V(".mode-btn"),j=O(".formula-card"),h=b("canvas"),h&&(i=h.getContext("2d")),P=O(".visual-card"),m=5,c=3,d="II",p=!1,v.value=m,E.value=c,v.max=f,E.max=f,I&&(I.textContent=m),D&&(D.textContent=c),Z.forEach(t=>{t.dataset.mode===d?t.classList.add("active"):t.classList.remove("active")}),q(),A(),y(),setTimeout(()=>{C(),y()},100)}function q(){v.addEventListener("input",t=>{m=parseInt(t.target.value),I.textContent=m,A(),y()}),E.addEventListener("input",t=>{c=parseInt(t.target.value),D.textContent=c,A(),y()}),Z.forEach(t=>{t.addEventListener("click",()=>{Z.forEach(n=>n.classList.remove("active")),t.classList.add("active"),d=t.dataset.mode,p=!1,y()})}),j.addEventListener("click",t=>{w[d].formulaZh.includes(`
`)&&(p=!p,y())}),P.addEventListener("click",()=>{A(),T()}),window.addEventListener("resize",()=>{const t=window.innerWidth<640?7:10;t!==f&&(f=t,v.max=f,E.max=f,m>f&&(m=f,v.value=m,I.textContent=m),c>f&&(c=f,E.value=c,D.textContent=c),y()),C()}),v.max=f,E.max=f,C()}function C(){const t=h.parentElement;h.width=t.clientWidth,h.height=t.clientHeight,T()}function y(){if(!d||!w[d])return;const t=w[d],n=t.calculate(f,f,p),s=n.matrix||n,r=s[m]?s[m][c]:0,e=x=>x?x.replace(/{n}/g,m).replace(/{m}/g,c).replace(/{res}/g,r):"",l=b("explanation-zh"),o=b("explanation-en");l&&(l.innerText=e(t.explainZh)),o&&(o.innerText=e(t.explainEn));const a=b("recurrence-formula");if(a)if(t.formulaZh.includes(`
`)){a.style.cursor="pointer",a.title="点击切换递推演示 / Click to toggle recurrence demo";const x=t.formulaZh.split(`
`),g=t.modeLabels||[];a.innerHTML=`<div class="${p?"":"active-formula"}">${g[0]?`<b>${g[0]}</b><br>`:""}${x[0]}</div>
                            <div class="${p?"active-formula":""}">${g[1]?`<b>${g[1]}</b><br>`:""}${x[1]}</div>`}else a.innerHTML=t.formulaZh.replace(`
`,"<br>"),a.style.cursor="default",a.title="";const u=b("closed-formula");u&&(u.innerHTML=t.closedZh||""),H(),T()}function H(){const t=w[d],n=t.calculate(f,f,p),s=n.matrix||n;let r="<table><thead><tr><th>n\\m</th>";for(let e=0;e<=f;e++)r+=`<th>${e}</th>`;r+="</tr></thead><tbody>";for(let e=0;e<=f;e++){r+=`<tr><th>${e}</th>`;for(let l=0;l<=f;l++){let o=s[e][l];const a=e===m&&l===c;let u="";p&&(d==="DI"?u=n.componentMatrix[e][l]:d==="II"&&(e>=l?u=s[e-l][l]:u=0));let x=a?"cell-active":"",g="",M=u!==""?`<span class="cell-corner">${u}</span>`:"";d==="DI"&&p&&n.componentMatrix;const k=t.getDependencies(m,c,p).find(L=>L.r===e&&L.c===l);k&&(d==="DI"&&p&&!a&&(o=n.componentMatrix[e][l]),a?x+=" cell-source-overlap":x=k.cls,k.label&&(g=`<span class="cell-label">${k.label}</span>`)),r+=`<td class="${x}" data-r="${e}" data-c="${l}">${g}${M}${o}</td>`}r+="</tr>"}r+="</tbody></table>",R.innerHTML=r,R.querySelectorAll("td").forEach(e=>{e.addEventListener("click",()=>{m=parseInt(e.dataset.r),c=parseInt(e.dataset.c),v.value=m,E.value=c,I.textContent=m,D.textContent=c,y()})})}function A(){if(S=Array.from({length:c},()=>[]),d.startsWith("D"))for(let t=0;t<m;t++){const n=Math.floor(Math.random()*c);S[n].push(t)}else{let t=m;for(let n=0;n<c-1;n++){const s=Math.floor(Math.random()*(t+1));for(let r=0;r<s;r++)S[n].push("ball");t-=s}for(let n=0;n<t;n++)S[c-1].push("ball")}d.endsWith("I")&&S.sort((t,n)=>n.length-t.length)}function T(){i.clearRect(0,0,h.width,h.height);const t=50,n=80,s=60,r=(h.width-2*t-c*n)/(c-1||1);i.fillStyle="#fff",i.font="bold 16px Outfit",i.textAlign="center";const e=w[d].calculate(10,10),l=e.matrix||e;i.fillText(`${m} Balls → ${c} Boxes: ${l[m][c]} ways`,h.width/2,30),i.font="12px Outfit",i.fillStyle=B("--text-secondary"),i.fillText("(点击卡片切换示例 / Click card to cycle examples)",h.width/2,50);for(let o=0;o<c;o++){const a=t+o*(n+r),u=h.height-120;i.strokeStyle=B("--accent-color"),i.lineWidth=2,i.strokeRect(a,u,n,s),i.fillStyle=B("--text-secondary"),i.font="12px Outfit",i.textAlign="center";const x=d.endsWith("D")?`Box ${o+1}`:`Part ${o+1}`;i.fillText(x,a+n/2,u+s+20);const g=S[o],M=6;g.forEach(($,k)=>{const L=a+15+k%4*15,N=u+15+Math.floor(k/4)*15;i.beginPath(),i.arc(L,N,M,0,Math.PI*2),typeof $=="number"?(i.fillStyle=`hsl(${$*360/m}, 70%, 60%)`,i.fill(),i.fillStyle="#fff",i.font="8px Outfit",i.fillText($+1,L,N+3)):(i.fillStyle=B("--text-secondary"),i.fill())})}}function B(t){const n=getComputedStyle(document.documentElement).getPropertyValue(t).trim();return n||(t==="--accent-color"?"#38bdf8":t==="--text-secondary"?"#94a3b8":"#ffffff")}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",W):W();window.addEventListener("load",()=>{C(),y()});
