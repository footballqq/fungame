(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const l of e)if(l.type==="childList")for(const o of l.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function s(e){const l={};return e.integrity&&(l.integrity=e.integrity),e.referrerPolicy&&(l.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?l.credentials="include":e.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(e){if(e.ep)return;e.ep=!0;const l=s(e);fetch(e.href,l)}})();const S={II:{id:"II",nameZh:"相同球 相同盒",nameEn:"Identical Balls, Identical Boxes",calculate:(t,n,s=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let e=0;e<=n;e++)r[0][e]=1;for(let e=1;e<=t;e++)for(let l=1;l<=n;l++)r[e][l]=r[e][l-1],e>=l&&(r[e][l]+=r[e-l][l]);return r},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-m, m)
递推 2：f(n, m) = Σ_{k=1}^m f(n-k, k)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-m, m)
Recurrence 2: f(n, m) = Σ_{k=1}^m f(n-k, k)`,closedZh:"组合意义：整数分拆 (Partitions of n into ≤ m parts)",closedEn:"Note: Integer partitions of n into at most m parts",explainZh:`相同球相同盒 (整数分拆)。总数 f(n, m) 表示将 n 拆分为不超过 m 个正整数之和。
【视角 1】：讨论是否有空盒。f(n, m-1) 表示至少一个空盒；f(n-m, m) 表示全部装满（先各发一个球）。
【视角 2】：按非空盒子数 k 累加。由组合恒等式可知，分拆为“恰好 k 组”的方法数等于 f(n-k, k)。将 k 从 1 到 m 累加即得总数，在矩阵中形成斜线。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种分拆方式。`,explainEn:`Identical Balls, Identical Boxes (Integer Partitions).
[View 1]: Empty boxes f(n, m-1) vs No empty boxes f(n-m, m).
[View 2]: Summing over non-empty box count k. The number of partitions into "exactly k" parts equals f(n-k, k). Summing k from 1 to m forms a diagonal.
[Result]: When n={n}, m={m}, there are {res} ways.`,modeLabels:["视角 1 (空盒递归)","视角 2 (斜线累加)"],getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=1;e<=n;e++)t-e>=0&&r.push({r:t-e,c:e,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"空盒"},{r:t-n,c:n,cls:"cell-source-2",label:"全满"}]}},DI:{id:"DI",nameZh:"不同球 相同盒",nameEn:"Distinct Balls, Identical Boxes",calculate:(t,n,s=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));r[0][0]=1;for(let l=1;l<=t;l++)for(let o=1;o<=n;o++)r[l][o]=o*r[l-1][o]+r[l-1][o-1];if(!s)return{matrix:r,isStirling:!0};const e=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let l=0;l<=t;l++)for(let o=1;o<=n;o++){let a=0;for(let f=1;f<=o;f++)a+=r[l][f];e[l][o]=l===0?1:a}return{matrix:e,componentMatrix:r}},formulaZh:`递推 1 (恰好 m 盒)：S(n, m) = m·S(n-1, m) + S(n-1, m-1)
公式 2 (至多 m 盒)：f(n, m) = Σ_{k=1}^m S(n, k)`,formulaEn:`Recurrence 1 (Exactly m): S(n, m) = m·S(n-1, m) + S(n-1, m-1)
Formula 2 (At most m): f(n, m) = Σ_{k=1}^m S(n, k)`,closedZh:"组合意义：不同球放入相同盒子 (盒子间无区别，像完全一样的袋子)",closedEn:"Note: Distinct balls into identical boxes (Individual items in generic bags)",explainZh:`不同球相同盒 (斯特林数)。由于盒子不可辨，第 n 个球放在哪个空盒里都没有区别。
【深度推导】：考虑第 n 个球的去向：
1. 它单独占领一个新盒子：剩下 n-1 个球放在 m-1 个盒子里，即 S(n-1, m-1)。
2. 它不单独占盒子：而是挤进已有的 m 个盒子之一。因为它有 m 种选择，所以是 m * S(n-1, m)。
【总数逻辑】：如果要计算“至多 m 盒”，则需将放入 1 到 m 个盒子的方案数全部相加：f(n, m) = Σ S(n, k)。
【当前结果】：当 n={n}, m={m} 时，总方案数为 {res}。`,explainEn:`Distinct Balls, Identical Boxes (Stirling Numbers).
[Deep Reasoning]: Since boxes are indistinguishable, it doesn't matter which empty box the n-th ball enters.
1. n-th ball forms its own box: Put the other n-1 balls into m-1 boxes → S(n-1, m-1).
2. n-th ball joins an existing box: There are m occupied boxes to choose from → m * S(n-1, m).
[Total Logic]: For "At most m boxes", we sum options from 1 to m: f(n, m) = Σ S(n, k).
[Result]: When n={n}, m={m}, there are {res} ways in total.`,modeLabels:["恰好 m 盒 (Exactly m)","至多 m 盒 (At most m)"],getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=1;e<=n;e++)r.push({r:t,c:e,cls:"cell-source-group",label:`k=${e}`,useStirling:!0});return r}else return[{r:t-1,c:n,cls:"cell-source-1",label:"m×"},{r:t-1,c:n-1,cls:"cell-source-2"}]}},ID:{id:"ID",nameZh:"相同球 不同盒",nameEn:"Identical Balls, Distinct Boxes",calculate:(t,n,s=!1)=>{const e=Array.from({length:31},()=>Array(31).fill(0));for(let o=0;o<=30;o++){e[o][0]=1;for(let a=1;a<=o;a++)e[o][a]=e[o-1][a-1]+e[o-1][a]}const l=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let o=0;o<=t;o++)for(let a=1;a<=n;a++)l[o][a]=e[o+a-1][a-1];return l},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-1, m)
递推 2：f(n, m) = Σ_{k=0}^n f(k, m-1)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-1, m)
Recurrence 2: f(n, m) = Σ_{k=0}^n f(k, m-1)`,closedZh:"组合意义：隔板法 (C(n+m-1, m-1))",closedEn:"Note: Identical balls into distinct boxes (Stars and Bars)",modeLabels:["递推 1 (增量递归)","递推 2 (逐项累加)"],explainZh:`相同球不同盒 (隔板法)。
【书本做法】：使用隔板法，通解为 C(n+m-1, m-1)。
【递推推导】：如果你已经知道部分结果，可以通过最后一个盒子来推导：
最后一个盒子可以放 0 个，1 个... 一直到 n 个球。如果最后一个盒子放了 k 个，那么剩下的球就放进前 m-1 个盒子，方案数为 f(n-k, m-1)。
【更简递推】：f(n, m) = f(n, m-1) [第一个盒子为空] + f(n-1, m) [第一个盒子至少有1个球]。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种放法。`,explainEn:`Identical Balls, Distinct Boxes (Stars and Bars).
[Standard View]: General solution is C(n+m-1, m-1).
[Recursive Reasoning]: You can derive more results from known ones using the "last box" logic:
The last box can contain k balls (where 0 ≤ k ≤ n). For each choice of k, the remaining balls are distributed in m-1 boxes, giving Σ f(n-k, m-1).
[Simplified]: f(n, m) = f(n, m-1) [1st box empty] + f(n-1, m) [1st box ≥ 1 ball].
[Result]: When n={n}, m={m}, there are {res} ways.`,getDependencies:(t,n,s=!1)=>{if(s){const r=[];for(let e=0;e<=t;e++)r.push({r:e,c:n-1,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"0球"},{r:t-1,c:n,cls:"cell-source-2",label:"≥1球"}]}},DD:{id:"DD",nameZh:"不同球 不同盒",nameEn:"Distinct Balls, Distinct Boxes",calculate:(t,n)=>{const s=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let r=0;r<=n;r++)s[0][r]=1;for(let r=1;r<=t;r++)for(let e=0;e<=n;e++)s[r][e]=Math.pow(e,r);return s},formulaZh:"递推式：f(n, m) = m · f(n-1, m)",formulaEn:"Recurrence: f(n, m) = m · f(n-1, m)",closedZh:"通项公式：m^n (每个球有 m 种选择)",closedEn:"General Form: m^n (Each ball has m choices)",explainZh:`不同球不同盒 (指数模型)。
【基本逻辑】：对于每个球来说都有 m 种选择（盒子是不同的），所以总共有 m^n 种方案。
【递归通式】：假设你已经放好了 n-1 个球，即 f(n-1, m)。现在要放第 n 个球，它有 m 种选盒子的方法。因此：f(n, m) = m * f(n-1, m)。
【边界条件】：f(0, m) = 1 (没有球也是 1 种状态)。
【当前结果】：当 n={n}, m={m} 时，共有 {m}^{n} = {res} 种放法。`,explainEn:`Distinct Balls, Distinct Boxes (Exponential Model).
[Basic Logic]: Each of the n distinct balls has m choices of distinct boxes, leading to m^n.
[Recursive Logic]: Suppose n-1 balls are already placed, f(n-1, m). For the n-th ball, there are m box options. Thus: f(n, m) = m * f(n-1, m).
[Boundary]: f(0, m) = 1.
[Result]: When n={n}, m={m}, there are {m}^{n} = {res} ways.`,getDependencies:(t,n)=>[{r:t-1,c:n,cls:"cell-source-1",label:"m×"}]}};let u="II",m=5,i=3,d=!1,x=[];const Z=document.getElementById("n-input"),M=document.getElementById("m-input"),R=document.getElementById("n-val"),C=document.getElementById("m-val"),$=document.getElementById("matrix-container"),w=document.querySelectorAll(".mode-btn"),T=document.querySelector(".formula-card"),h=document.getElementById("canvas"),c=h.getContext("2d"),N=document.querySelector(".visual-card");function j(){O(),v(),b()}function O(){Z.addEventListener("input",t=>{m=parseInt(t.target.value),R.textContent=m,v(),b()}),M.addEventListener("input",t=>{i=parseInt(t.target.value),C.textContent=i,v(),b()}),w.forEach(t=>{t.addEventListener("click",()=>{w.forEach(n=>n.classList.remove("active")),t.classList.add("active"),u=t.dataset.mode,d=!1,b()})}),T.addEventListener("click",t=>{S[u].formulaZh.includes(`
`)&&(d=!d,b())}),N.addEventListener("click",()=>{v(),D()}),window.addEventListener("resize",()=>A()),A()}function A(){const t=h.parentElement;h.width=t.clientWidth,h.height=t.clientHeight,D()}function b(){const t=S[u],n=t.calculate(10,10,d),r=(n.matrix||n)[m][i],e=o=>o.replace(/{n}/g,m).replace(/{m}/g,i).replace(/{res}/g,r);document.getElementById("explanation-zh").innerText=e(t.explainZh),document.getElementById("explanation-en").innerText=e(t.explainEn);const l=document.getElementById("recurrence-formula");if(l.innerHTML=t.formulaZh.replace(`
`,"<br>"),t.formulaZh.includes(`
`)){l.style.cursor="pointer",l.title="点击切换递推演示 / Click to toggle recurrence demo";const o=t.formulaZh.split(`
`),a=t.modeLabels||[];l.innerHTML=`<div class="${d?"":"active-formula"}">${a[0]?`<b>${a[0]}</b><br>`:""}${o[0]}</div>
                        <div class="${d?"active-formula":""}">${a[1]?`<b>${a[1]}</b><br>`:""}${o[1]}</div>`}else l.style.cursor="default",l.title="";document.getElementById("closed-formula").innerHTML=t.closedZh,P(),D()}function P(){const t=S[u],n=t.calculate(10,10,d),s=n.matrix||n;let r="<table><thead><tr><th>n\\m</th>";for(let e=0;e<=10;e++)r+=`<th>${e}</th>`;r+="</tr></thead><tbody>";for(let e=0;e<=10;e++){r+=`<tr><th>${e}</th>`;for(let l=0;l<=10;l++){let o=s[e][l];const a=e===m&&l===i;let f="";d&&(u==="DI"?f=n.componentMatrix[e][l]:u==="II"&&(e>=l?f=s[e-l][l]:f=0));let g=a?"cell-active":"",E="",B=f!==""?`<span class="cell-corner">${f}</span>`:"";u==="DI"&&d&&n.componentMatrix;const p=t.getDependencies(m,i,d).find(y=>y.r===e&&y.c===l);p&&(u==="DI"&&d&&!a&&(o=n.componentMatrix[e][l]),a?g+=" cell-source-overlap":g=p.cls,p.label&&(E=`<span class="cell-label">${p.label}</span>`)),r+=`<td class="${g}" data-r="${e}" data-c="${l}">${E}${B}${o}</td>`}r+="</tr>"}r+="</tbody></table>",$.innerHTML=r,$.querySelectorAll("td").forEach(e=>{e.addEventListener("click",()=>{m=parseInt(e.dataset.r),i=parseInt(e.dataset.c),Z.value=m,M.value=i,R.textContent=m,C.textContent=i,b()})})}function v(){if(x=Array.from({length:i},()=>[]),u.startsWith("D"))for(let t=0;t<m;t++){const n=Math.floor(Math.random()*i);x[n].push(t)}else{let t=m;for(let n=0;n<i-1;n++){const s=Math.floor(Math.random()*(t+1));for(let r=0;r<s;r++)x[n].push("ball");t-=s}for(let n=0;n<t;n++)x[i-1].push("ball")}u.endsWith("I")&&x.sort((t,n)=>n.length-t.length)}function D(){c.clearRect(0,0,h.width,h.height);const t=50,n=80,s=60,r=(h.width-2*t-i*n)/(i-1||1);c.fillStyle="#fff",c.font="bold 16px Outfit",c.textAlign="center";const e=S[u].calculate(10,10),l=e.matrix||e;c.fillText(`${m} Balls → ${i} Boxes: ${l[m][i]} ways`,h.width/2,30),c.font="12px Outfit",c.fillStyle=k("--text-secondary"),c.fillText("(点击卡片切换示例 / Click card to cycle examples)",h.width/2,50);for(let o=0;o<i;o++){const a=t+o*(n+r),f=h.height-120;c.strokeStyle=k("--accent-color"),c.lineWidth=2,c.strokeRect(a,f,n,s),c.fillStyle=k("--text-secondary"),c.font="12px Outfit",c.textAlign="center";const g=u.endsWith("D")?`Box ${o+1}`:`Part ${o+1}`;c.fillText(g,a+n/2,f+s+20);const E=x[o],B=6;E.forEach((I,p)=>{const y=a+15+p%4*15,L=f+15+Math.floor(p/4)*15;c.beginPath(),c.arc(y,L,B,0,Math.PI*2),typeof I=="number"?(c.fillStyle=`hsl(${I*360/m}, 70%, 60%)`,c.fill(),c.fillStyle="#fff",c.font="8px Outfit",c.fillText(I+1,y,L+3)):(c.fillStyle=k("--text-secondary"),c.fill())})}}function k(t){return getComputedStyle(document.documentElement).getPropertyValue(t).trim()}j();
