/* empty css              */(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const l of e)if(l.type==="childList")for(const o of l.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function a(e){const l={};return e.integrity&&(l.integrity=e.integrity),e.referrerPolicy&&(l.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?l.credentials="include":e.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(e){if(e.ep)return;e.ep=!0;const l=a(e);fetch(e.href,l)}})();const A={II:{id:"II",nameZh:"相同球 相同盒",nameEn:"Identical Balls, Identical Boxes",calculate:(t,n,a=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let e=0;e<=n;e++)r[0][e]=1;for(let e=1;e<=t;e++)for(let l=1;l<=n;l++)r[e][l]=r[e][l-1],e>=l&&(r[e][l]+=r[e-l][l]);return r},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-m, m)
递推 2：f(n, m) = Σ_{k=1}^m f(n-k, k)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-m, m)
Recurrence 2: f(n, m) = Σ_{k=1}^m f(n-k, k)`,closedZh:"组合意义：整数分拆 (Partitions of n into ≤ m parts)",closedEn:"Note: Integer partitions of n into at most m parts",explainZh:`相同球相同盒 (整数分拆)。总数 f(n, m) 表示将 n 拆分为不超过 m 个正整数之和。
【视角 1】：讨论是否有空盒。f(n, m-1) 表示至少一个空盒；f(n-m, m) 表示全部装满（先各发一个球）。
【视角 2】：按非空盒子数 k 累加。由组合恒等式可知，分拆为“恰好 k 组”的方法数等于 f(n-k, k)。将 k 从 1 到 m 累加即得总数，在矩阵中形成斜线。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种分拆方式。`,explainEn:`Identical Balls, Identical Boxes (Integer Partitions).
[View 1]: Empty boxes f(n, m-1) vs No empty boxes f(n-m, m).
[View 2]: Summing over non-empty box count k. The number of partitions into "exactly k" parts equals f(n-k, k). Summing k from 1 to m forms a diagonal.
[Result]: When n={n}, m={m}, there are {res} ways.`,modeLabels:["视角 1 (空盒递归)","视角 2 (斜线累加)"],getDependencies:(t,n,a=!1)=>{if(a){const r=[];for(let e=1;e<=n;e++)t-e>=0&&r.push({r:t-e,c:e,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"空盒"},{r:t-n,c:n,cls:"cell-source-2",label:"全满"}]}},DI:{id:"DI",nameZh:"不同球 相同盒",nameEn:"Distinct Balls, Identical Boxes",calculate:(t,n,a=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));r[0][0]=1;for(let l=1;l<=t;l++)for(let o=1;o<=n;o++)r[l][o]=o*r[l-1][o]+r[l-1][o-1];if(!a)return{matrix:r,isStirling:!0};const e=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let l=0;l<=t;l++)for(let o=1;o<=n;o++){let s=0;for(let d=1;d<=o;d++)s+=r[l][d];e[l][o]=l===0?1:s}return{matrix:e,componentMatrix:r}},formulaZh:`递推 1 (恰好 m 盒)：S(n, m) = m·S(n-1, m) + S(n-1, m-1)
公式 2 (至多 m 盒)：f(n, m) = Σ_{k=1}^m S(n, k)`,formulaEn:`Recurrence 1 (Exactly m): S(n, m) = m·S(n-1, m) + S(n-1, m-1)
Formula 2 (At most m): f(n, m) = Σ_{k=1}^m S(n, k)`,closedZh:"组合意义：不同球放入相同盒子 (盒子间无区别，像完全一样的袋子)",closedEn:"Note: Distinct balls into identical boxes (Individual items in generic bags)",explainZh:`不同球相同盒 (斯特林数)。由于盒子不可辨，第 n 个球放在哪个空盒里都没有区别。
【深度推导】：考虑第 n 个球的去向：
1. 它单独占领一个新盒子：剩下 n-1 个球放在 m-1 个盒子里，即 S(n-1, m-1)。
2. 它不单独占盒子：而是挤进已有的 m 个盒子之一。因为它有 m 种选择，所以是 m * S(n-1, m)。
【总数逻辑】：如果要计算“至多 m 盒”，则需将放入 1 到 m 个盒子的方案数全部相加：f(n, m) = Σ S(n, k)。
【当前结果】：当 n={n}, m={m} 时，总方案数为 {res}。`,explainEn:`Distinct Balls, Identical Boxes (Stirling Numbers).
[Deep Reasoning]: Since boxes are indistinguishable, it doesn't matter which empty box the n-th ball enters.
1. n-th ball forms its own box: Put the other n-1 balls into m-1 boxes → S(n-1, m-1).
2. n-th ball joins an existing box: There are m occupied boxes to choose from → m * S(n-1, m).
[Total Logic]: For "At most m boxes", we sum options from 1 to m: f(n, m) = Σ S(n, k).
[Result]: When n={n}, m={m}, there are {res} ways in total.`,modeLabels:["恰好 m 盒 (Exactly m)","至多 m 盒 (At most m)"],getDependencies:(t,n,a=!1)=>{if(a){const r=[];for(let e=1;e<=n;e++)r.push({r:t,c:e,cls:"cell-source-group",label:`k=${e}`,useStirling:!0});return r}else return[{r:t-1,c:n,cls:"cell-source-1",label:"m×"},{r:t-1,c:n-1,cls:"cell-source-2"}]}},ID:{id:"ID",nameZh:"相同球 不同盒",nameEn:"Identical Balls, Distinct Boxes",calculate:(t,n,a=!1)=>{const e=Array.from({length:31},()=>Array(31).fill(0));for(let o=0;o<=30;o++){e[o][0]=1;for(let s=1;s<=o;s++)e[o][s]=e[o-1][s-1]+e[o-1][s]}const l=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let o=0;o<=t;o++)for(let s=1;s<=n;s++)l[o][s]=e[o+s-1][s-1];return l},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-1, m)
递推 2：f(n, m) = Σ_{k=0}^n f(k, m-1)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-1, m)
Recurrence 2: f(n, m) = Σ_{k=0}^n f(k, m-1)`,closedZh:"组合意义：隔板法 (C(n+m-1, m-1))",closedEn:"Note: Identical balls into distinct boxes (Stars and Bars)",modeLabels:["递推 1 (增量递归)","递推 2 (逐项累加)"],explainZh:`相同球不同盒 (隔板法)。
【书本做法】：使用隔板法，通解为 C(n+m-1, m-1)。
【逐项累加推导】：想象有 n 个球分给 m 个小朋友。我们按【最后一个小朋友拿到了几个球】来分类：
- 他拿 0 个：剩下的球分给前 m-1 人，即 f(n, m-1)；
- 他拿 1 个：剩下的球分给前 m-1 人，即 f(n-1, m-1)；
- ...直到他拿走所有球。
把这些所有互斥的情况加起来，就是总数。因此 f(n, m) = Σ f(k, m-1)。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种放法。`,explainEn:`Identical Balls, Distinct Boxes (Stars and Bars).
[Standard View]: General solution is C(n+m-1, m-1).
[Recursive Reasoning]: You can derive more results from known ones using the "last box" logic:
The last box can contain k balls (where 0 ≤ k ≤ n). For each choice of k, the remaining balls are distributed in m-1 boxes, giving Σ f(n-k, m-1).
[Simplified]: f(n, m) = f(n, m-1) [1st box empty] + f(n-1, m) [1st box ≥ 1 ball].
[Result]: When n={n}, m={m}, there are {res} ways.`,getDependencies:(t,n,a=!1)=>{if(a){const r=[];for(let e=0;e<=t;e++)r.push({r:e,c:n-1,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"0球"},{r:t-1,c:n,cls:"cell-source-2",label:"≥1球"}]}},DD:{id:"DD",nameZh:"不同球 不同盒",nameEn:"Distinct Balls, Distinct Boxes",calculate:(t,n)=>{const a=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let r=0;r<=n;r++)a[0][r]=1;for(let r=1;r<=t;r++)for(let e=0;e<=n;e++)a[r][e]=Math.pow(e,r);return a},formulaZh:"递推式：f(n, m) = m · f(n-1, m)",formulaEn:"Recurrence: f(n, m) = m · f(n-1, m)",closedZh:"通项公式：m^n (每个球有 m 种选择)",closedEn:"General Form: m^n (Each ball has m choices)",explainZh:`不同球不同盒 (指数模型)。
【基本逻辑】：对于每个球来说都有 m 种选择（盒子是不同的），所以总共有 m^n 种方案。
【递归通式】：假设你已经放好了 n-1 个球，即 f(n-1, m)。现在要放第 n 个球，它有 m 种选盒子的方法。因此：f(n, m) = m * f(n-1, m)。
【边界条件】：f(0, m) = 1 (没有球也是 1 种状态)。
【当前结果】：当 n={n}, m={m} 时，共有 {m}^{n} = {res} 种放法。`,explainEn:`Distinct Balls, Distinct Boxes (Exponential Model).
[Basic Logic]: Each of the n distinct balls has m choices of distinct boxes, leading to m^n.
[Recursive Logic]: Suppose n-1 balls are already placed, f(n-1, m). For the n-th ball, there are m box options. Thus: f(n, m) = m * f(n-1, m).
[Boundary]: f(0, m) = 1.
[Result]: When n={n}, m={m}, there are {m}^{n} = {res} ways.`,getDependencies:(t,n)=>[{r:t-1,c:n,cls:"cell-source-1",label:"m×"}]}};let u="II",m=5,c=3,h=!1,g=[];const y=document.getElementById("n-input"),E=document.getElementById("m-input"),w=document.getElementById("n-val"),L=document.getElementById("m-val"),R=document.getElementById("matrix-container"),T=document.querySelectorAll(".mode-btn"),O=document.querySelector(".formula-card"),p=document.getElementById("canvas"),i=p.getContext("2d"),W=document.querySelector(".visual-card");let f=window.innerWidth<640?7:10;function N(){m=parseInt(y.value)||5,c=parseInt(E.value)||3,w.textContent=m,L.textContent=c;const t=document.querySelector(".mode-btn.active");t&&(u=t.dataset.mode),j(),D(),x(),$(),x()}function j(){y.addEventListener("input",t=>{m=parseInt(t.target.value),w.textContent=m,D(),x()}),E.addEventListener("input",t=>{c=parseInt(t.target.value),L.textContent=c,D(),x()}),T.forEach(t=>{t.addEventListener("click",()=>{T.forEach(n=>n.classList.remove("active")),t.classList.add("active"),u=t.dataset.mode,h=!1,x()})}),O.addEventListener("click",t=>{A[u].formulaZh.includes(`
`)&&(h=!h,x())}),W.addEventListener("click",()=>{D(),M()}),window.addEventListener("resize",()=>{const t=window.innerWidth<640?7:10;t!==f&&(f=t,y.max=f,E.max=f,m>f&&(m=f,y.value=m,w.textContent=m),c>f&&(c=f,E.value=c,L.textContent=c),x()),$()}),y.max=f,E.max=f,$()}function $(){const t=p.parentElement;p.width=t.clientWidth,p.height=t.clientHeight,M()}function x(){const t=A[u],n=t.calculate(f,f,h),r=(n.matrix||n)[m][c],e=o=>o.replace(/{n}/g,m).replace(/{m}/g,c).replace(/{res}/g,r);document.getElementById("explanation-zh").innerText=e(t.explainZh),document.getElementById("explanation-en").innerText=e(t.explainEn);const l=document.getElementById("recurrence-formula");if(l.innerHTML=t.formulaZh.replace(`
`,"<br>"),t.formulaZh.includes(`
`)){l.style.cursor="pointer",l.title="点击切换递推演示 / Click to toggle recurrence demo";const o=t.formulaZh.split(`
`),s=t.modeLabels||[];l.innerHTML=`<div class="${h?"":"active-formula"}">${s[0]?`<b>${s[0]}</b><br>`:""}${o[0]}</div>
                        <div class="${h?"active-formula":""}">${s[1]?`<b>${s[1]}</b><br>`:""}${o[1]}</div>`}else l.style.cursor="default",l.title="";document.getElementById("closed-formula").innerHTML=t.closedZh,P(),M()}function P(){const t=A[u],n=t.calculate(f,f,h),a=n.matrix||n;let r="<table><thead><tr><th>n\\m</th>";for(let e=0;e<=f;e++)r+=`<th>${e}</th>`;r+="</tr></thead><tbody>";for(let e=0;e<=f;e++){r+=`<tr><th>${e}</th>`;for(let l=0;l<=f;l++){let o=a[e][l];const s=e===m&&l===c;let d="";h&&(u==="DI"?d=n.componentMatrix[e][l]:u==="II"&&(e>=l?d=a[e-l][l]:d=0));let v=s?"cell-active":"",S="",C=d!==""?`<span class="cell-corner">${d}</span>`:"";u==="DI"&&h&&n.componentMatrix;const b=t.getDependencies(m,c,h).find(I=>I.r===e&&I.c===l);b&&(u==="DI"&&h&&!s&&(o=n.componentMatrix[e][l]),s?v+=" cell-source-overlap":v=b.cls,b.label&&(S=`<span class="cell-label">${b.label}</span>`)),r+=`<td class="${v}" data-r="${e}" data-c="${l}">${S}${C}${o}</td>`}r+="</tr>"}r+="</tbody></table>",R.innerHTML=r,R.querySelectorAll("td").forEach(e=>{e.addEventListener("click",()=>{m=parseInt(e.dataset.r),c=parseInt(e.dataset.c),y.value=m,E.value=c,w.textContent=m,L.textContent=c,x()})})}function D(){if(g=Array.from({length:c},()=>[]),u.startsWith("D"))for(let t=0;t<m;t++){const n=Math.floor(Math.random()*c);g[n].push(t)}else{let t=m;for(let n=0;n<c-1;n++){const a=Math.floor(Math.random()*(t+1));for(let r=0;r<a;r++)g[n].push("ball");t-=a}for(let n=0;n<t;n++)g[c-1].push("ball")}u.endsWith("I")&&g.sort((t,n)=>n.length-t.length)}function M(){i.clearRect(0,0,p.width,p.height);const t=50,n=80,a=60,r=(p.width-2*t-c*n)/(c-1||1);i.fillStyle="#fff",i.font="bold 16px Outfit",i.textAlign="center";const e=A[u].calculate(10,10),l=e.matrix||e;i.fillText(`${m} Balls → ${c} Boxes: ${l[m][c]} ways`,p.width/2,30),i.font="12px Outfit",i.fillStyle=B("--text-secondary"),i.fillText("(点击卡片切换示例 / Click card to cycle examples)",p.width/2,50);for(let o=0;o<c;o++){const s=t+o*(n+r),d=p.height-120;i.strokeStyle=B("--accent-color"),i.lineWidth=2,i.strokeRect(s,d,n,a),i.fillStyle=B("--text-secondary"),i.font="12px Outfit",i.textAlign="center";const v=u.endsWith("D")?`Box ${o+1}`:`Part ${o+1}`;i.fillText(v,s+n/2,d+a+20);const S=g[o],C=6;S.forEach((k,b)=>{const I=s+15+b%4*15,Z=d+15+Math.floor(b/4)*15;i.beginPath(),i.arc(I,Z,C,0,Math.PI*2),typeof k=="number"?(i.fillStyle=`hsl(${k*360/m}, 70%, 60%)`,i.fill(),i.fillStyle="#fff",i.font="8px Outfit",i.fillText(k+1,I,Z+3)):(i.fillStyle=B("--text-secondary"),i.fill())})}}function B(t){return getComputedStyle(document.documentElement).getPropertyValue(t).trim()}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",N):N();window.addEventListener("load",()=>{$(),x()});
