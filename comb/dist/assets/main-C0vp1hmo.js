/* empty css              */(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const l of e)if(l.type==="childList")for(const o of l.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function a(e){const l={};return e.integrity&&(l.integrity=e.integrity),e.referrerPolicy&&(l.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?l.credentials="include":e.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(e){if(e.ep)return;e.ep=!0;const l=a(e);fetch(e.href,l)}})();const C={II:{id:"II",nameZh:"相同球 相同盒",nameEn:"Identical Balls, Identical Boxes",calculate:(t,n,a=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let e=0;e<=n;e++)r[0][e]=1;for(let e=1;e<=t;e++)for(let l=1;l<=n;l++)r[e][l]=r[e][l-1],e>=l&&(r[e][l]+=r[e-l][l]);return r},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-m, m)
递推 2：f(n, m) = Σ_{k=1}^m f(n-k, k)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-m, m)
Recurrence 2: f(n, m) = Σ_{k=1}^m f(n-k, k)`,closedZh:"组合意义：整数分拆 (Partitions of n into ≤ m parts)",closedEn:"Note: Integer partitions of n into at most m parts",explainZh:`相同球相同盒 (整数分拆)。总数 f(n, m) 表示将 n 拆分为不超过 m 个正整数之和。
【视角 1】：讨论是否有空盒。f(n, m-1) 表示至少一个空盒；f(n-m, m) 表示全部装满（先各发一个球）。
【视角 2】：按非空盒子数 k 累加。由组合恒等式可知，分拆为“恰好 k 组”的方法数等于 f(n-k, k)。将 k 从 1 到 m 累加即得总数，在矩阵中形成斜线。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种分拆方式。`,explainEn:`Identical Balls, Identical Boxes (Integer Partitions).
[View 1]: Empty boxes f(n, m-1) vs No empty boxes f(n-m, m).
[View 2]: Summing over non-empty box count k. The number of partitions into "exactly k" parts equals f(n-k, k). Summing k from 1 to m forms a diagonal.
[Result]: When n={n}, m={m}, there are {res} ways.`,modeLabels:["视角 1 (空盒递归)","视角 2 (斜线累加)"],getDependencies:(t,n,a=!1)=>{if(a){const r=[];for(let e=1;e<=n;e++)t-e>=0&&r.push({r:t-e,c:e,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"空盒"},{r:t-n,c:n,cls:"cell-source-2",label:"全满"}]}},DI:{id:"DI",nameZh:"不同球 相同盒",nameEn:"Distinct Balls, Identical Boxes",calculate:(t,n,a=!1)=>{const r=Array.from({length:t+1},()=>Array(n+1).fill(0));r[0][0]=1;for(let l=1;l<=t;l++)for(let o=1;o<=n;o++)r[l][o]=o*r[l-1][o]+r[l-1][o-1];if(!a)return{matrix:r,isStirling:!0};const e=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let l=0;l<=t;l++)for(let o=1;o<=n;o++){let i=0;for(let u=1;u<=o;u++)i+=r[l][u];e[l][o]=l===0?1:i}return{matrix:e,componentMatrix:r}},formulaZh:`递推 1 (恰好 m 盒)：S(n, m) = m·S(n-1, m) + S(n-1, m-1)
公式 2 (至多 m 盒)：f(n, m) = Σ_{k=1}^m S(n, k)`,formulaEn:`Recurrence 1 (Exactly m): S(n, m) = m·S(n-1, m) + S(n-1, m-1)
Formula 2 (At most m): f(n, m) = Σ_{k=1}^m S(n, k)`,closedZh:"组合意义：不同球放入相同盒子 (盒子间无区别，像完全一样的袋子)",closedEn:"Note: Distinct balls into identical boxes (Individual items in generic bags)",explainZh:`不同球相同盒 (斯特林数)。由于盒子不可辨，第 n 个球放在哪个空盒里都没有区别。
【深度推导】：考虑第 n 个球的去向：
1. 它单独占领一个新盒子：剩下 n-1 个球放在 m-1 个盒子里，即 S(n-1, m-1)。
2. 它不单独占盒子：而是挤进已有的 m 个盒子之一。因为它有 m 种选择，所以是 m * S(n-1, m)。
【总数逻辑】：如果要计算“至多 m 盒”，则需将放入 1 到 m 个盒子的方案数全部相加：f(n, m) = Σ S(n, k)。
【当前结果】：当 n={n}, m={m} 时，总方案数为 {res}。`,explainEn:`Distinct Balls, Identical Boxes (Stirling Numbers).
[Deep Reasoning]: Since boxes are indistinguishable, it doesn't matter which empty box the n-th ball enters.
1. n-th ball forms its own box: Put the other n-1 balls into m-1 boxes → S(n-1, m-1).
2. n-th ball joins an existing box: There are m occupied boxes to choose from → m * S(n-1, m).
[Total Logic]: For "At most m boxes", we sum options from 1 to m: f(n, m) = Σ S(n, k).
[Result]: When n={n}, m={m}, there are {res} ways in total.`,modeLabels:["恰好 m 盒 (Exactly m)","至多 m 盒 (At most m)"],getDependencies:(t,n,a=!1)=>{if(a){const r=[];for(let e=1;e<=n;e++)r.push({r:t,c:e,cls:"cell-source-group",label:`k=${e}`,useStirling:!0});return r}else return[{r:t-1,c:n,cls:"cell-source-1",label:"m×"},{r:t-1,c:n-1,cls:"cell-source-2"}]}},ID:{id:"ID",nameZh:"相同球 不同盒",nameEn:"Identical Balls, Distinct Boxes",calculate:(t,n,a=!1)=>{const e=Array.from({length:31},()=>Array(31).fill(0));for(let o=0;o<=30;o++){e[o][0]=1;for(let i=1;i<=o;i++)e[o][i]=e[o-1][i-1]+e[o-1][i]}const l=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let o=0;o<=t;o++)for(let i=1;i<=n;i++)l[o][i]=e[o+i-1][i-1];return l},formulaZh:`递推 1：f(n, m) = f(n, m-1) + f(n-1, m)
递推 2：f(n, m) = Σ_{k=0}^n f(k, m-1)`,formulaEn:`Recurrence 1: f(n, m) = f(n, m-1) + f(n-1, m)
Recurrence 2: f(n, m) = Σ_{k=0}^n f(k, m-1)`,closedZh:"组合意义：隔板法 (C(n+m-1, m-1))",closedEn:"Note: Identical balls into distinct boxes (Stars and Bars)",modeLabels:["递推 1 (增量递归)","递推 2 (逐项累加)"],explainZh:`相同球不同盒 (隔板法)。
【书本做法】：使用隔板法，通解为 C(n+m-1, m-1)。
【逐项累加推导】：想象有 n 个球分给 m 个小朋友。我们按【最后一个小朋友拿到了几个球】来分类：
- 他拿 0 个：剩下的球分给前 m-1 人，即 f(n, m-1)；
- 他拿 1 个：剩下的球分给前 m-1 人，即 f(n-1, m-1)；
- ...直到他拿走所有球。
把这些所有互斥的情况加起来，就是总数。因此 f(n, m) = Σ f(k, m-1)。
【当前结果】：当 n={n}, m={m} 时，共有 {res} 种放法。`,explainEn:`Identical Balls, Distinct Boxes (Stars and Bars).
[Standard View]: General solution is C(n+m-1, m-1).
[Recursive Reasoning]: You can derive more results from known ones using the "last box" logic:
The last box can contain k balls (where 0 ≤ k ≤ n). For each choice of k, the remaining balls are distributed in m-1 boxes, giving Σ f(n-k, m-1).
[Simplified]: f(n, m) = f(n, m-1) [1st box empty] + f(n-1, m) [1st box ≥ 1 ball].
[Result]: When n={n}, m={m}, there are {res} ways.`,getDependencies:(t,n,a=!1)=>{if(a){const r=[];for(let e=0;e<=t;e++)r.push({r:e,c:n-1,cls:"cell-source-group",label:`k=${e}`});return r}else return[{r:t,c:n-1,cls:"cell-source-1",label:"0球"},{r:t-1,c:n,cls:"cell-source-2",label:"≥1球"}]}},DD:{id:"DD",nameZh:"不同球 不同盒",nameEn:"Distinct Balls, Distinct Boxes",calculate:(t,n)=>{const a=Array.from({length:t+1},()=>Array(n+1).fill(0));for(let r=0;r<=n;r++)a[0][r]=1;for(let r=1;r<=t;r++)for(let e=0;e<=n;e++)a[r][e]=Math.pow(e,r);return a},formulaZh:"递推式：f(n, m) = m · f(n-1, m)",formulaEn:"Recurrence: f(n, m) = m · f(n-1, m)",closedZh:"通项公式：m^n (每个球有 m 种选择)",closedEn:"General Form: m^n (Each ball has m choices)",explainZh:`不同球不同盒 (指数模型)。
【基本逻辑】：对于每个球来说都有 m 种选择（盒子是不同的），所以总共有 m^n 种方案。
【递归通式】：假设你已经放好了 n-1 个球，即 f(n-1, m)。现在要放第 n 个球，它有 m 种选盒子的方法。因此：f(n, m) = m * f(n-1, m)。
【边界条件】：f(0, m) = 1 (没有球也是 1 种状态)。
【当前结果】：当 n={n}, m={m} 时，共有 {m}^{n} = {res} 种放法。`,explainEn:`Distinct Balls, Distinct Boxes (Exponential Model).
[Basic Logic]: Each of the n distinct balls has m choices of distinct boxes, leading to m^n.
[Recursive Logic]: Suppose n-1 balls are already placed, f(n-1, m). For the n-th ball, there are m box options. Thus: f(n, m) = m * f(n-1, m).
[Boundary]: f(0, m) = 1.
[Result]: When n={n}, m={m}, there are {m}^{n} = {res} ways.`,getDependencies:(t,n)=>[{r:t-1,c:n,cls:"cell-source-1",label:"m×"}]}};let d="II",f=5,c=3,p=!1,E=[],x,b,I,k,M,N,j,h,s,P;const v=t=>document.getElementById(t),V=t=>document.querySelectorAll(t),R=t=>document.querySelector(t);let m=window.innerWidth<640?7:10;function O(){if(x=v("n-input"),b=v("m-input"),I=v("n-val"),k=v("m-val"),M=v("matrix-container"),N=V(".mode-btn"),j=R(".formula-card"),h=v("canvas"),h&&(s=h.getContext("2d")),P=R(".visual-card"),!x||!b||!M){console.error("Critical UI elements not found!");return}m=window.innerWidth<640?7:10;let t=parseInt(x.value),n=parseInt(b.value);f=Math.min(isNaN(t)?5:t,m),c=Math.min(isNaN(n)?3:n,m),x.value=f,b.value=c,x.max=m,b.max=m,I&&(I.textContent=f),k&&(k.textContent=c);const a=R(".mode-btn.active");a&&(d=a.dataset.mode),q(),$(),g(),setTimeout(()=>{A(),g()},150)}function q(){x.addEventListener("input",t=>{f=parseInt(t.target.value),I.textContent=f,$(),g()}),b.addEventListener("input",t=>{c=parseInt(t.target.value),k.textContent=c,$(),g()}),N.forEach(t=>{t.addEventListener("click",()=>{N.forEach(n=>n.classList.remove("active")),t.classList.add("active"),d=t.dataset.mode,p=!1,g()})}),j.addEventListener("click",t=>{C[d].formulaZh.includes(`
`)&&(p=!p,g())}),P.addEventListener("click",()=>{$(),T()}),window.addEventListener("resize",()=>{const t=window.innerWidth<640?7:10;t!==m&&(m=t,x.max=m,b.max=m,f>m&&(f=m,x.value=f,I.textContent=f),c>m&&(c=m,b.value=c,k.textContent=c),g()),A()}),x.max=m,b.max=m,A()}function A(){const t=h.parentElement;h.width=t.clientWidth,h.height=t.clientHeight,T()}function g(){const t=C[d],n=t.calculate(m,m,p),r=(n.matrix||n)[f][c],e=o=>o.replace(/{n}/g,f).replace(/{m}/g,c).replace(/{res}/g,r);document.getElementById("explanation-zh").innerText=e(t.explainZh),document.getElementById("explanation-en").innerText=e(t.explainEn);const l=document.getElementById("recurrence-formula");if(l.innerHTML=t.formulaZh.replace(`
`,"<br>"),t.formulaZh.includes(`
`)){l.style.cursor="pointer",l.title="点击切换递推演示 / Click to toggle recurrence demo";const o=t.formulaZh.split(`
`),i=t.modeLabels||[];l.innerHTML=`<div class="${p?"":"active-formula"}">${i[0]?`<b>${i[0]}</b><br>`:""}${o[0]}</div>
                        <div class="${p?"active-formula":""}">${i[1]?`<b>${i[1]}</b><br>`:""}${o[1]}</div>`}else l.style.cursor="default",l.title="";document.getElementById("closed-formula").innerHTML=t.closedZh,H(),T()}function H(){const t=C[d],n=t.calculate(m,m,p),a=n.matrix||n;let r="<table><thead><tr><th>n\\m</th>";for(let e=0;e<=m;e++)r+=`<th>${e}</th>`;r+="</tr></thead><tbody>";for(let e=0;e<=m;e++){r+=`<tr><th>${e}</th>`;for(let l=0;l<=m;l++){let o=a[e][l];const i=e===f&&l===c;let u="";p&&(d==="DI"?u=n.componentMatrix[e][l]:d==="II"&&(e>=l?u=a[e-l][l]:u=0));let S=i?"cell-active":"",w="",Z=u!==""?`<span class="cell-corner">${u}</span>`:"";d==="DI"&&p&&n.componentMatrix;const y=t.getDependencies(f,c,p).find(D=>D.r===e&&D.c===l);y&&(d==="DI"&&p&&!i&&(o=n.componentMatrix[e][l]),i?S+=" cell-source-overlap":S=y.cls,y.label&&(w=`<span class="cell-label">${y.label}</span>`)),r+=`<td class="${S}" data-r="${e}" data-c="${l}">${w}${Z}${o}</td>`}r+="</tr>"}r+="</tbody></table>",M.innerHTML=r,M.querySelectorAll("td").forEach(e=>{e.addEventListener("click",()=>{f=parseInt(e.dataset.r),c=parseInt(e.dataset.c),x.value=f,b.value=c,I.textContent=f,k.textContent=c,g()})})}function $(){if(E=Array.from({length:c},()=>[]),d.startsWith("D"))for(let t=0;t<f;t++){const n=Math.floor(Math.random()*c);E[n].push(t)}else{let t=f;for(let n=0;n<c-1;n++){const a=Math.floor(Math.random()*(t+1));for(let r=0;r<a;r++)E[n].push("ball");t-=a}for(let n=0;n<t;n++)E[c-1].push("ball")}d.endsWith("I")&&E.sort((t,n)=>n.length-t.length)}function T(){s.clearRect(0,0,h.width,h.height);const t=50,n=80,a=60,r=(h.width-2*t-c*n)/(c-1||1);s.fillStyle="#fff",s.font="bold 16px Outfit",s.textAlign="center";const e=C[d].calculate(10,10),l=e.matrix||e;s.fillText(`${f} Balls → ${c} Boxes: ${l[f][c]} ways`,h.width/2,30),s.font="12px Outfit",s.fillStyle=L("--text-secondary"),s.fillText("(点击卡片切换示例 / Click card to cycle examples)",h.width/2,50);for(let o=0;o<c;o++){const i=t+o*(n+r),u=h.height-120;s.strokeStyle=L("--accent-color"),s.lineWidth=2,s.strokeRect(i,u,n,a),s.fillStyle=L("--text-secondary"),s.font="12px Outfit",s.textAlign="center";const S=d.endsWith("D")?`Box ${o+1}`:`Part ${o+1}`;s.fillText(S,i+n/2,u+a+20);const w=E[o],Z=6;w.forEach((B,y)=>{const D=i+15+y%4*15,W=u+15+Math.floor(y/4)*15;s.beginPath(),s.arc(D,W,Z,0,Math.PI*2),typeof B=="number"?(s.fillStyle=`hsl(${B*360/f}, 70%, 60%)`,s.fill(),s.fillStyle="#fff",s.font="8px Outfit",s.fillText(B+1,D,W+3)):(s.fillStyle=L("--text-secondary"),s.fill())})}}function L(t){return getComputedStyle(document.documentElement).getPropertyValue(t).trim()}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",O):O();window.addEventListener("load",()=>{A(),g()});
