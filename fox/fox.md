# N洞抓狐狸（fox）程序设计说明

## 1. 目标与玩法

这是一个单页网页小游戏：山上有 **2~10 个洞口**（默认 5），小狐狸初始躲在其中一个洞口。玩家每天早晨只能检查 1 个洞口：

- 若检查到狐狸则立即获胜。
- 若没抓到，则夜晚狐狸必定跳到**相邻**洞口（不会原地不动），进入下一天继续。

游戏提供两种难度：

- **简单（easy）**：狐狸在相邻洞口中随机移动。
- **困难（hard）**：**作弊对抗模式**。程序不预先固定狐狸初始位置，而是维护“可能位置集合”；只要存在一条逃跑路径能让玩家抓不到，就一直抓不到；只有当玩家把狐狸逼到“必然位置”时才会抓到（结束后回放会展示一条合理的逃跑路线）。

游戏会记录完整过程，并支持：

- 抓捕日志（游戏过程中显示“你查了几号”）
- 结束后揭示每回合狐狸真实位置
- 回放（逐步/自动）
- 复制调试记录、复制分享文案

需求草案来源：`fox/foxprompt.txt`。

## 2. 目录与文件职责

`fox/` 目录包含一个纯前端实现（无构建步骤）：

- `fox/index.html`：页面结构与 UI 入口（按钮、洞口容器、日志、两个弹窗）。
- `fox/style.css`：整体可爱卡通风格、洞口布局、弹窗、响应式适配与少量动画。
- `fox/script.js`：核心游戏逻辑（状态机、狐狸移动算法、日志/回放/分享/复制）。
- `fox/foxprompt.txt`：最初需求与调试样例（非运行时依赖）。

## 3. 页面结构（index.html）

主要区域：

- 顶部标题与规则提示。
- 控制区：洞口数选择（2~10）、难度切换（简单/困难）、攻略弹窗按钮、重置按钮。
- 状态栏：当前天数与提示消息。
- 场景区：洞口容器 `#holes-container`（洞口由 JS 动态生成）。
- 回放区 `#replay-controls`：上一/下一步、自动播放、分享、再玩一次（默认隐藏，结束后展示）。
- 日志区 `#log-container`：抓捕记录列表 `#game-log`，并包含“复制记录”按钮（默认隐藏，结束后展示）。

两个弹窗：

- `#intro-modal`：游戏介绍，点击“开始抓捕！”后才真正开始新一局。
- `#strategy-modal`：静态攻略说明（由按钮打开/关闭，不参与算法计算）。

## 4. 样式设计（style.css）

样式以 CSS 变量统一主题色（背景、主色、辅色、草地、洞口），并围绕“触屏友好”做了设计：

- `.hole-wrapper` 作为可点击单元，hover/active 有轻微缩放反馈。
- `.content` 用来显示洞口上方的“狐狸/空/提示”符号，并通过 transform/opacity 做出出现/半透明效果。
- `.modal` + `.modal-content` 实现介绍/攻略弹窗，内部支持滚动以适配小屏。
- 响应式：
  - 平板：增大洞口与字体
  - 手机：控制区纵向排列、洞口按视口宽度缩放、按钮铺满

## 5. 核心逻辑（script.js）

### 5.1 核心类与状态模型

`script.js` 以 `FoxGame` 类组织全部逻辑，并在 `DOMContentLoaded` 时创建实例：

- 常量/状态
  - `holes`：洞口数量（来自 UI 选择，范围 2~10）
  - `foxPosition`：狐狸当前洞口（0-based）
  - `day`：当前“白天”的天数（从 1 开始）
  - `history`：回合记录数组（用于结算揭示 + 回放）
  - `difficulty`：`easy` / `hard`
  - `isGameOver`：是否已结束
  - `isReplaying`：是否处于回放状态（回放时禁止继续点击）
  - `isProcessingTurn`：是否在处理回合（防止连点导致同一回合多次执行）

- UI 引用集中在 `this.ui`（通过 `document.getElementById` 获取），便于统一绑定事件与更新界面。

### 5.2 游戏开始与重置

- `init()`：绑定事件，不自动开局（等待介绍弹窗确认）。
- `startNewGame()`：读取洞口数，重置所有状态并初始化狐狸位置（简单模式随机；困难模式初始化“可能位置集合”），清空日志与回放 UI，重新渲染 N 个洞口：
  - 每个洞口由 `.hole-wrapper` 包裹，展示编号（1~N），并绑定点击事件 `checkHole(i)`。

### 5.3 回合流程（白天检查 → 夜晚移动 → 次日）

玩家点击洞口触发 `checkHole(index)`（异步）：

1. **守卫条件**：若 `isGameOver` / `isReplaying` / `isProcessingTurn` / `hasCheckedToday` 为真则直接返回（确保每天只能查 1 次）。
2. 记录“本回合开始时”的快照 `turnRecord` 并准备写入 `history`：
   - `day`：当天
   - `foxPosAtStart`：本回合开始时狐狸位置
   - `playerCheck`：玩家检查位置
   - `caught`：是否抓到
3. **命中（抓到）**：
   - 显示狐狸符号并将其设置为实像（`opacity = 1`）
   - 更新提示消息为获胜
   - 写入 `history`，调用 `endGame(true)` 进入结算/回放
4. **未命中**：
   - 在玩家检查洞口显示“空/烟尘”符号（并降透明度）
   - 追加过程日志（只记玩家查了哪号）
   - 写入 `history`
   - 进入 `nightPhase(index)`：清理洞口显示 → 等待 → 夜晚移动（简单：随机；困难：更新可能集合）→ `day++` → 更新天数与提示

由此实现了 `foxprompt.txt` 中“第一天狐狸选洞猎人找；晚上狐狸换洞；第二天再找”的节奏：`day` 只在夜晚移动后递增。

### 5.4 狐狸移动算法

#### 简单模式（easy）

`moveFox()` 每晚从相邻洞口中等概率随机选择下一位置（狐狸不会原地不动）。

#### 困难模式（hard，作弊对抗）

困难模式不固定 `foxPosition`，而是维护“狐狸在当天早晨可能所在的位置集合” `possibleFoxPositions`：

- 当天早晨玩家检查洞口 `k`：
  - 若 `possibleFoxPositions = {k}`（集合只有一个元素且等于 `k`），说明狐狸已被逼到“必然位置”，当场抓到。
  - 否则一定判定为“没抓到”（因为狐狸可以选择集合中其它位置）。
- 夜晚移动时：
  - 先把 `k` 从集合里剔除（因为白天没抓到，狐狸不可能在 `k`）
  - 再把集合中每个位置扩展到其相邻洞口，得到下一天早晨的新集合

结束后，程序会根据每天的集合与相邻约束回溯构造一条合理的狐狸逃跑路径，并写入 `history[*].foxPosAtStart`，用于日志揭示与回放显示。

#### 必胜序列（2~10 洞）

攻略弹窗中展示的序列由 `getWinningSequence(holeCount)` 生成：

- `N=2`：`1 → 1`（2 天保证抓到）
- `N>=3`：`2 → 3 → ... → (N-1) → (N-1) → ... → 3 → 2`
- 保证天数：`N=2` 时为 2；`N>=3` 时为 `2N - 4` 天

### 5.5 记录、结算揭示与回放

- `history` 存储每次点击对应的回合快照，因此：
  - **结算揭示**（`revealLogs()`）可以显示“第 N 天你查了 X 号 + 狐狸当时在 Y 号”。
  - **回放**（`renderReplayState(stepIndex)`）可以复原任意一步的盘面：
    - 显示该步回合开始时狐狸所在洞口（抓到时实像，否则半透明）
    - 标记玩家检查洞口 `.checked`，并在未命中时显示“空/烟尘”
- `setupReplay()` 初始化回放指针为 0，更新按钮禁用状态与 `stepInfo`。
- `replayStep(direction)` 按步进更新 `replayIndex` 并渲染。
- `autoPlayReplay()` 每 1.5 秒自动前进一格直到结束。

### 5.6 分享与复制调试信息

- `shareResult()`：把分享文案写入剪贴板（含固定网址、洞口数、难度、用时天数）。
- `copyDebugLogs()`：把更详细的调试日志写入剪贴板（包含洞口数、每回合狐狸位置、玩家检查位置、胜负）。

注意：剪贴板 API 在部分浏览器/协议下可能受限（例如 `file://` 打开时），更稳定的方式是在 `http(s)://` 环境访问。

## 6. 运行方式

直接用浏览器打开 `fox/index.html` 即可开始游戏（无构建步骤、无服务端依赖）。

## 7. 可扩展点（后续迭代建议）

- **困难模式策略**：当前实现为“作弊对抗”，可替换为其它 AI（例如：非作弊但更聪明的策略、或提供不同难度档）。
- **资源替换**：洞口与狐狸目前使用符号/表情展示，可替换为图片素材（保持 `.content` 区域渲染即可）。
- **分享链接配置**：`shareResult()` 中的固定 URL 可抽为常量或从 `location` 自动生成，避免部署环境变化后忘记更新。
